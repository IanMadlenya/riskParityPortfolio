% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/riskParityPortfolio.R
\name{riskParityPortfolio}
\alias{riskParityPortfolio}
\title{Design of Risk Parity Portfolios}
\usage{
riskParityPortfolio(Sigma, b = NULL, mu = NULL, lmd_mu = 1e-04,
  lmd_var = 0, w_lb = 0, w_ub = 1,
  method_init = c("cyclical-spinu", "cyclical-roncalli", "newton"),
  method = c("sca", "alabama", "slsqp"), formulation = NULL,
  w0 = NULL, theta0 = NULL, gamma = 0.9, zeta = 1e-07,
  tau = NULL, maxiter = 50, ftol = 1e-08, wtol = 1e-06,
  use_gradient = TRUE)
}
\arguments{
\item{Sigma}{covariance or correlation matrix (this is the only mandatory argument)}

\item{b}{budget vector, i.e., the risk budgeting targets. The default is the
uniform 1/N vector.}

\item{mu}{vector of expected returns (only needed if the expected return term
is desired in the objective)}

\item{lmd_mu}{scalar to control the importance of the expected return term}

\item{lmd_var}{scalar to control the importance of the variance term
(only currently available for the SCA method).}

\item{w_lb}{lower bound on the value of each portfolio weight. If a vector,
then the lower bound is applied element-wise
(only currently available for the SCA method). If a scalar, ...}

\item{w_ub}{upper bound on the value of each portfolio weight. If a vector,
then the upper bound is applied element-wise
(only available for the SCA method for now).}

\item{method_init}{method to compute the vanilla solution. In case of additional blah blah blah,
this solution is used as the initial point for the subsequent method. The default is 
\code{"cyclical-spinu"}.}

\item{method}{method to solve the non-vanilla formulation. The default is \code{"sca"}.}

\item{formulation}{string indicating the risk concentration formulation to be used.
It must be one of: \code{"diag", "rc-double-index",
"rc-over-b-double-index", "rc-over-var vs b", "rc-over-var",
"rc-over-sd vs b-times-sd", "rc vs b-times-var", "rc vs theta", or
"rc-over-b vs theta"}. The default is XXXX. 
If \code{formulation} is not provided and no additional terms
or constraints are set, such as expected return or shortselling, then
the vanilla risk parity portfolio will be returned. If formulation is
\code{"diag"} then the analytical solution of the risk parity optimization for
for a diagonal covariance matrix will be returned. In the latter case,
if additional terms or constraints are given, then an error will be raised.}

\item{w0}{initial value for the portfolio weights. Default is a convex
combination among the risk-parity, the (uncorrelated) minimum variance,
and the maximum return portfolios.}

\item{theta0}{initial value for theta (in case formulation uses theta). If not provided,
the optimum solution for a fixed vector of portfolio weights will be used.}

\item{gamma}{learning rate for the SCA method}

\item{zeta}{factor used to decrease the learning rate at each iteration for the SCA method}

\item{tau}{regularization factor. If not provided, a meaningful value will be used.}

\item{maxiter}{maximum number of iterations for the SCA loop}

\item{ftol}{convergence tolerance on the objective function}

\item{wtol}{convergence tolerance on the values of the portfolio weights}

\item{use_gradient}{(this parameter is meaningful only if method is either
\code{"alabama"} or \code{"slsqp"}) if \code{TRUE}, gradients of the objective function wrt
to the parameters will be used. This is strongly recommended to achieve faster results.}
}
\value{
A list containing possibly the following elements:
\item{\code{w}}{optimal portfolio vector}
\item{\code{risk_contribution}}{the risk contribution of every asset}
\item{\code{theta}}{the optimal value for theta (in case that it is part of
                    the chosen formulation)}
\item{\code{obj_fun}}{the sequence of values from the objective function at
                      each iteration}
\item{\code{risk_parity}}{the risk concentration term of the portfolio R(w)}
\item{\code{mean_return}}{the expected return term of the portoflio w'*mu, 
                          if the term is included in the optimization}
\item{\code{variance}}{the variance term of the portfolio w'*Sigma*w, 
                       if the variance term is included in the optimization}
\item{\code{elapsed_time}}{elapsed time recorded at every iteration}
\item{\code{convergence}}{flag to indicate whether or not the optimization
converged}
}
\description{
Design of Risk Parity Portfolios
}
\details{
By default, the problem considered is the vanilla risk-parity portfolio: 
w>=0, no other box constraints, no expected return, and no variance. In this case,
the optimal solution is computed and risk concentration is zero: R(w) = 0. By default, 
we use the formulation by Spinu (2013) (method_init = ""), but the user can also select
the formulation by Roncalli et al. (2013) (method_init = "").

In case of additional box constraints, or additional expected return term, 
or additional variance term, then the problem is nonconvex and the global
optimal solution cannot be guaranteed, just a local optimal. We use the method
in Feng&Paloamr (2015), where the user can choose among many different risk concentration
terms (with the argument \code{method}), namely:
\item{\code{method="asdfa"}}{sum_{i,j} (r_i - r_j)^2 (by default)}
\item{\code{method="asdfa"}}{sum_{i,j} (r_i - r_j)^2 (by default)}
- \code{method="asdfa"}: sum_{i,j} (r_i - r_j)^2 (by default)
- \code{method="asdfas"l}: dasfasdf
- \code{method="asdfasd"}: adfadf
where r_i = w_i * (Sigma %*% w)_i


This is what you wrote:
Note that, in case the additional terms (expected return or variance) or
box constraints are not desired, then this function will solve a convex
problem proposed by Spinu (2013) and by Roncalli (2013) with guaranteed
global solution as long as the covariance matrix is positive semidefinite.

For more details, please check the vignette.
}
\examples{
library(riskParityPortfolio)

# create covariance matrix
N <- 5
V <- matrix(rnorm(N^2), ncol = N)
Sigma <- cov(V)

# risk-parity portfolio
res <- riskParityPortfolio(Sigma)
names(res)
#> [1] "w"                 "risk_contribution"
res$w
#> [1] 0.04142886 0.38873465 0.34916787 0.09124019 0.12942842
res$risk_contribution
#> [1] 0.007361995 0.007361995 0.007361995 0.007361995 0.007361995
c(res$w * (Sigma \%*\% res$w))
#> [1] 0.007361995 0.007361995 0.007361995 0.007361995 0.007361995

# risk budggeting portfolio
res <- riskParityPortfolio(Sigma, b = c(0.4, 0.4, 0.1, 0.05, 0.05))
res$risk_contribution/sum(res$risk_contribution)
#> [1] 0.40 0.40 0.10 0.05 0.05

}
\references{
Y. Feng, and D. P. Palomar (2015). SCRIP: Successive Convex Optimization Methods
for Risk Parity Portfolio Design. \emph{IEEE Trans. on Signal Processing},
vol. 63, no. 19, pp. 5285-5300. <https://doi.org/10.1109/TSP.2015.2452219>

F. Spinu (2013). An Algorithm for Computing Risk Parity Weights.
<https://dx.doi.org/10.2139/ssrn.2297383>

T. Griveau-Billion, J. Richard, and T. Roncalli (2013). A fast algorithm for computing High-dimensional
risk parity portfolios. <https://arxiv.org/pdf/1311.4057.pdf>
}
\author{
Ze Vinicius and Daniel P. Palomar
}
