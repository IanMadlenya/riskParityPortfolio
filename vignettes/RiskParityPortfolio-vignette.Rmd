---
title: "Design of Risk Parity Portfolios"
author: "Convex Group - HKUST"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    base_format: prettydoc::html_pretty
    theme: tactile
    highlight: vignette
    fig_caption: yes
    number_sections: no
    toc: yes
    toc_depth: 2
  bookdown::pdf_document2:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 2
header-includes:
  \allowdisplaybreaks
indent: yes
csl: ieee.csl
bibliography: refs.bib
vignette: >
  %\VignetteIndexEntry{Design of Risk Parity Portfolios}
  %\VignetteKeyword{portfolio, risk-parity, risk, optimization}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r, echo = FALSE}
library(knitr)
opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center",
  fig.retina = 2,
  out.width = "75%",
  dpi = 96
)
knit_hooks$set(pngquant = hook_pngquant)
#Help on bookdown: https://bookdown.org/yihui/bookdown/
#rmarkdown::render("vignettes/SparseIndexTracking-vignette.Rmd", "all")
#rmarkdown::render("vignettes/SparseIndexTracking-vignette.Rmd", "bookdown::html_document2")
#rmarkdown::render("vignettes/SparseIndexTracking-vignette.Rmd", "bookdown::pdf_document2")
#tools::compactPDF("vignettes/SparseIndexTracking-vignette.pdf", gs_quality = "ebook")
```

-----------
> This vignette illustrates the design of risk-parity portfolios, widely
used by practitioners in the financial industry, with the package
`riskParityPortfolio` (with a comparison with other packages) and gives a
description of the algorithms used.


# Comparison with other packages
Existing packages that I quickly found (a more thorough search is due):

- Package [cccp](https://CRAN.R-project.org/package=cccp) contains function
  `rp` (and the package itself may be useful for solving conic optimization problems)
- Package [FinCovRegularization](https://CRAN.R-project.org/package=FinCovRegularization)
  contains function `RiskParity` (the package may be useful for covariance matrix
  regularization, which is one of my upcoming projects...)


# Usage of the package

```{r, cache = TRUE}
library(riskParityPortfolio)
library(xts)
library(quantmod)
library(PerformanceAnalytics)

set.seed(123)

N <- 10
stocks_index <- c(1:N)
Sigma <- diag(stocks_index ^ 2)
S <- matrix(runif(N ^ 2), nrow = N)
Sigma <- Sigma + 10 * (S + t(S))

# compute the portfolio weights for the case when Sigma is diagonal
w_diag <- 1 / sqrt(diag(Sigma))
w_diag <- w_diag/sum(w_diag)
# Vinicius: let's write a function for the diagonal case to be used like this:
# res_diag <- riskParityPortfolioDiagSigma(diag(Sigma))
# in the function description we need to say that it is for sum(w)=1 and w>=0.
# Oh, to be consistent, it should return a list with the elements w and risk_contribution
```

## Formulations (Vinicius: please take a look and revise and include the formulations from my .Rmd file)
In its simples version, the risk-parity portfolio aims at achieving parity of the risk contributions from the different assets:
$$w_i\left(\boldsymbol{\Sigma}\mathbf{w}\right)_i = w_j\left(\boldsymbol{\Sigma}\mathbf{w}\right)_j \qquad \forall i,j.$$

Assuming that $\boldsymbol{\Sigma}$ is diagonal and with the constraints $\mathbf{1}^T\mathbf{w}=1$ and $\mathbf{w}\ge\mathbf{0}$, the risk budgeting portfolio is
$$w_i = \frac{\sqrt{b_i}/\sqrt{\Sigma_{ii}}}{\sum_{k=1}^N\sqrt{b_k}/\sqrt{\Sigma_{kk}}}, \qquad i=1,\ldots,N.$$
In general, exact parity cannot be achieved and one needs to define a risk term to be minimized: $R(\mathbf{w}) = \sum_{i=1}^{N}\left(g_{i}\left(\mathbf{w}\right)\right)^{2}$. A double-index summation can also be used:
$R(\mathbf{w}) = \sum_{i,j=1}^{N}\left(g_{ij}\left(\mathbf{w}\right)\right)^{2}$.



We condiser the following formulations (equation numbers from the paper):
(16): rc double-index
(17): rc vs theta
(22): rc-over-b vs theta
(18): norm-rc vs b
(19): rc-over-b double-index
(20): rc vs b-times-var
(21): rc-over-sd vs b-times-sd
(24): norm-rs
(26): group-rc-over-sd vs b-times-sd
(31): factor-rc-over-sd vs b-times-sd
(32): CVaR-rc-over-sd vs b-times-sd

And here give then one by one...

One of the earliest risk-parity portfolio formulations is
$$\begin{array}{ll}
\underset{\mathbf{w}}{\textsf{minimize}} & \sum_{i,j=1}^{N}\left(w_{i}\left(\boldsymbol{\Sigma}\mathbf{w}\right)_{i}-w_{j}\left(\boldsymbol{\Sigma}\mathbf{w}\right)_{j}\right)^{2}\\
\textsf{subject to} & \mathbf{1}^T\mathbf{w}=1,\quad\mathbf{w}\in\mathcal{W},
\end{array}$$
which corresponds to $g_{i,j}(\mathbf{w})=\mathbf{w}^T(\mathbf{M}_i-\mathbf{M}_j)\mathbf{w}$ (with $\mathcal{W}$ denoting some other constraints).

Another similar formulation is
$$\begin{array}{ll}
\underset{\mathbf{w},\theta}{\textsf{minimize}} & \sum_{i=1}^{N}\left(w_{i}\left(\boldsymbol{\Sigma}\mathbf{w}\right)_{i} - \theta\right)^{2}\\
\textsf{subject to} & \mathbf{1}^T\mathbf{w}=1,\quad\mathbf{w}\in\mathcal{W}.
\end{array}$$
which corresponds to $g_i(\mathbf{w})=\mathbf{w}^T\mathbf{M}_i\mathbf{w}-\theta$.






## Single-index case
```{r, cache = TRUE}
res_gen <- riskParityPortfolioGenSolver(Sigma, formulation = "single-index")
res_qp <- riskParityPortfolioSCA(Sigma, formulation = "single-index")

w_all <- cbind(res_gen$w, res_qp$w, w_diag)
colnames(w_all) <- c("risk-parity-gen-solver", "risk-parity-sca", "risk-parity-diag")
rownames(w_all) <- stocks_index
# Vinicius, if Sigma contains rownames or colnames, we should name w with those names, so the line above would be unnecessary (we should also name risk_contribution and so)
round(w_all, digits = 2)
barplot(t(w_all),
        main = "Portfolio allocation", xlab = "stocks", ylab = "dollars", beside = TRUE,
        legend = colnames(w_all), col = rainbow8equal[1:3])

risk_contrib_all <- cbind(res_gen$risk_contribution, res_qp$risk_contribution,
                          w_diag * (Sigma %*% w_diag))
colnames(risk_contrib_all) <- c("rc-gen-solver", "rc-sca", "rc-diag")
rownames(risk_contrib_all) <- stocks_index
barplot(t(risk_contrib_all),
        main = "Risk contribution", xlab = "stocks", beside = TRUE,
        legend = colnames(w_all), col = rainbow8equal[1:3])
plot(res_gen$elapsed_time, res_gen$obj_fun, type = "b", pch=19, cex=.6,
     col = "red", xlab = "Elapsed time (seconds)",
     ylab = "Objective function", main = "Convergence trend versus CPU time")
lines(res_qp$elapsed_time, res_qp$obj_fun, type = "b", pch=18, cex=.8,
      col = "blue")
legend("topright", legend=c("risk-parity-gen-solver", "risk-parity-sca"),
       col=c("red", "blue"), lty=c(1, 1), cex=0.8)
```

## Double-index case
```{r, cache = TRUE}
res_gen <- riskParityPortfolioGenSolver(Sigma, formulation = "double-index")
res_qp <- riskParityPortfolioSCA(Sigma, formulation = "double-index")

w_all <- cbind(res_gen$w, res_qp$w, w_diag)
colnames(w_all) <- c("risk-parity-gen-solver", "risk-parity-sca", "risk-parity-diag")
rownames(w_all) <- stocks_index
round(w_all, digits = 2)
barplot(t(w_all),
        main = "Portfolio allocation", xlab = "stocks", ylab = "dollars", beside = TRUE,
        legend = colnames(w_all), col = rainbow8equal[1:3])

risk_contrib_all <- cbind(res_gen$risk_contribution, res_qp$risk_contribution,
                          w_diag * (Sigma %*% w_diag))
colnames(risk_contrib_all) <- c("rc-gen-solver", "rc-sca", "rc-diag")
rownames(risk_contrib_all) <- stocks_index
barplot(t(risk_contrib_all),
        main = "Risk contribution", xlab = "stocks", beside = TRUE,
        legend = colnames(w_all), col = rainbow8equal[1:3])
plot(res_gen$elapsed_time, res_gen$obj_fun, type = "b", pch=19, cex=.6,
     col = "red", xlab = "Elapsed time (seconds)",
     ylab = "Objective function", main = "Convergence trend versus CPU time")
lines(res_qp$elapsed_time, res_qp$obj_fun, type = "b", pch=18, cex=.8,
      col = "blue")
legend("topright", legend=c("risk-parity-gen-solver", "risk-parity-sca"),
       col=c("red", "blue"), lty=c(1, 1), cex=0.8)
```


## Test with large number of stocks, single-index case
```{r, cache = TRUE}
set.seed(123)

N <- 100
S <- matrix(runif(N ^ 2), nrow = N)
Sigma <- 10 * (S + t(S))

res_gen <- riskParityPortfolioGenSolver(Sigma, formulation = "single-index")
res_gen_nograd <- riskParityPortfolioGenSolver(Sigma,
                                               formulation = "single-index",
                                               use_gradient = FALSE)
res_qp <- riskParityPortfolioSCA(Sigma, formulation = "single-index")

plot(res_gen$elapsed_time, res_gen$obj_fun, type = "b", pch=19, cex=.6,
     col = "red", xlab = "Elapsed time (seconds)",
     ylab = "Objective function", main = "Convergence trend versus CPU time")
lines(res_gen_nograd$elapsed_time, res_gen_nograd$obj_fun, type = "b", pch=18, cex=.8,
      col = "green")
lines(res_qp$elapsed_time, res_qp$obj_fun, type = "b", pch=18, cex=.8,
      col = "blue")
legend("topright", legend=c("risk-parity-gen-solver", "risk-parity-gen-solver-nograd",
                            "risk-parity-sca"),
       col=c("red", "green", "blue"), lty=c(1, 1, 1), cex=0.8)
```



# Explanation of the algorithms



# References {-}
\setlength{\parindent}{-0.2in}
\setlength{\leftskip}{0.2in}
\setlength{\parskip}{8pt}
\noindent
