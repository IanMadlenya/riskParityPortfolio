---
title: "Design of Risk Parity Portfolios"
author:
- name: "Zé Vinícius and Daniel P. Palomar"
  affiliation: "Hong Kong University of Science and Technology (HKUST)"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    base_format: prettydoc::html_pretty
    theme: cayman
    highlight: vignette
    fig_caption: yes
    number_sections: no
    toc: yes
    toc_depth: 2
  bookdown::pdf_document2:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 2
header-includes:
  \allowdisplaybreaks
indent: yes
csl: ieee.csl
bibliography: refs.bib
vignette: >
  %\VignetteIndexEntry{Design of Risk Parity Portfolios}
  %\VignetteKeyword{portfolio, risk-parity, risk, optimization}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r, echo = FALSE}
library(knitr)
opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center",
  fig.retina = 2,
  out.width = "75%",
  dpi = 96
)
knit_hooks$set(pngquant = hook_pngquant)
#Help on bookdown: https://bookdown.org/yihui/bookdown/
#rmarkdown::render("vignettes/RiskParityPortfolio-vignette.Rmd", "all")
#rmarkdown::render("vignettes/RiskParityPortfolio-vignette.Rmd", "bookdown::html_document2")
#rmarkdown::render("vignettes/RiskParityPortfolio-vignette.Rmd", "bookdown::pdf_document2")
#tools::compactPDF("vignettes/RiskParityPortfolio-vignette.pdf", gs_quality = "ebook")
```

-----------
This vignette illustrates the design of risk-parity portfolios, widely
used by practitioners in the financial industry, with the package
`riskParityPortfolio` and gives a description of the algorithms used.

# Usage of the package

We provide two functions to design risk parity portofolios: `riskParityPortfolioSCA()` and
`riskParityPortfolioGenSolver()`. The first one makes use of the successive convex approximation (SCA)
framework in order to optimize the portfolio weights, and it is based on the works of Feng & Palomar
[@FengPal2016monograph][@FengPal2015riskparity], whereas `riskParityPortfolioGenSolver()` uses general
solvers widely used by the R community such as `slsqp` and `alabama`.

A simple example on how to use those functions is as follows:

```{r, message = FALSE}
library(riskParityPortfolio)
library(xts)
library(quantmod)
library(PerformanceAnalytics)

# generate synthetic data
set.seed(123)
N <- 10
V <- matrix(rnorm(N ^ 2), nrow = N)
Sigma <- V %*% t(V)

# uniform initial guess for the portfolio weights
w0 <- rep(1/N, N)

# compute risk parity portfolios using different methods
sca <- riskParityPortfolioSCA(Sigma, w0 = w0)
slsqp <- riskParityPortfolioGenSolver(Sigma, w0 = w0, method = "slsqp")
alabama <- riskParityPortfolioGenSolver(Sigma, w0 = w0, method = "alabama")

# plot the portfolio designed by each method
barplot(rbind(sca$w, slsqp$w, alabama$w),
        main = "Portfolio Weights", xlab = "stocks", ylab = "dollars", 
        beside = TRUE, col = rainbow8equal[1:3], legend = c("sca", "slsqp", "alabama"))
# plot the risk contribution associated with each portfolio
barplot(rbind(sca$risk_contribution, slsqp$risk_contribution, alabama$risk_contribution),
        main = "Risk Contribution of the Portfolios", xlab = "stocks", ylab = "dollars", 
        beside = TRUE, col = rainbow8equal[1:3], legend = c("sca", "slsqp", "alabama"))
```
As we can observe, the risk parity portfolios are designed in such a way as to ensure equal risk
contribution from the assests.

Many more parameters are available in both `riskParityPortfolioSCA()` and `riskParityPortfolioGenSolver()`,
please, check the documentation for their full description.


# Performance comparison with other packages
Others R packages with the goal of designing risk parity portfolios do exist,
such as `FinCovRegularization` and `cccp`. Let's check how do they perform
against `riskParityPortfolio`.

```{r, message = FALSE}
library(FinCovRegularization)
library(cccp)

fincov <- RiskParity(Sigma)
fincov_risk_contribution <- c(fincov * (Sigma %*% fincov))
# The list of arguments is the following: 1) the initial guess for the portfolio weights,
# 2) the covariance matrix of the asset returns, 3) the marginal risk contributions
cccp_rp <- c(getx(rp(w0, Sigma, mrc = w0, optctrl = ctrl(trace = FALSE))))
cccp_risk_contribution <- c(cccp_rp * (Sigma %*% cccp_rp))

barplot(rbind(sca$w, slsqp$w, alabama$w, fincov, cccp_rp),
        main = "Portfolios Weights", xlab = "stocks", ylab = "dollars", 
        beside = TRUE, col = rainbow8equal[1:5], 
        legend = c("sca", "slsqp", "alabama", "FinCovRegularization", "cccp"))
barplot(rbind(sca$risk_contribution, slsqp$risk_contribution, alabama$risk_contribution, fincov_risk_contribution, cccp_risk_contribution),
        main = "Risk Contribution of the Portfolios", xlab = "stocks", ylab = "dollars", 
        beside = TRUE, col = rainbow8equal[1:5], 
        legend = c("sca", "slsqp", "alabama", "FinCovRegularization", "cccp"))
```

We can conclude that the function `RiskParity` from the `FinCovRegularization`
package fails to design a portfolio that meets the risk parity requirement
in a scenario with as few as ten assets. As for the `cccp` package, although it
works as expected, its API is a bit cumbersome specially for newcomers.

Now, let's take a look at the computational time taken by each function:

```{r}
library(microbenchmark)

N <- 100
V <- matrix(rnorm(N ^ 2), nrow = N)
Sigma <- V %*% t(V)
w0 <- rep(1/N, N)

op <- microbenchmark(SCA = riskParityPortfolioSCA(Sigma, w0 = w0),
                     GenSolver = riskParityPortfolioGenSolver(Sigma, w0 = w0),
                     CCCP = getx(rp(w0, Sigma, w0, optctrl = ctrl(trace = FALSE))),
                     times = 10L)
print(op)
par(mar = c(7, 4, 4, 2))
boxplot(op, ylab = "Time in Milliseconds", xlab = NULL, unit = "ms", outline = FALSE, las = 2)
```

Although the `rp()` function from the `cccp` package is around 6x faster than
`riskParityPortfolioSCA()`, `cccp` uses a formulation that is only applicable
for long-only portfolio [@Spinu2013], whereas the formulations available in
our package can be applied for the design of general long/short portfolios.


# Formulations
In its simples version, the risk-parity portfolio aims at achieving parity of the risk
contributions from the different assets: $$w_i\left(\boldsymbol{\Sigma}\mathbf{w}\right)_i = w_j\left(\boldsymbol{\Sigma}\mathbf{w}\right)_j \qquad \forall i,j.$$

Assuming that $\boldsymbol{\Sigma}$ is diagonal and with the constraints $\mathbf{1}^T\mathbf{w}=1$ and $\mathbf{w}\ge\mathbf{0}$, the risk budgeting portfolio is
$$w_i = \frac{\sqrt{b_i}/\sqrt{\Sigma_{ii}}}{\sum_{k=1}^N\sqrt{b_k}/\sqrt{\Sigma_{kk}}}, \qquad i=1,\ldots,N.$$
In general, exact parity cannot be achieved and one needs to define a risk term to be minimized: $R(\mathbf{w}) = \sum_{i=1}^{N}\left(g_{i}\left(\mathbf{w}\right)\right)^{2}$. A double-index summation can also be used:
$R(\mathbf{w}) = \sum_{i,j=1}^{N}\left(g_{ij}\left(\mathbf{w}\right)\right)^{2}$.

We condiser the following formulations (equation numbers from the paper):

- (16): rc double-index
- (17): rc-vs-theta
- (18): rc-over-var-vs-b
- (19): rc-over-b double-index
- (20): rc-vs-b-times-var
- (21): rc-over-sd vs b-times-sd
- (22): rc-over-b vs theta
- (24): rc-over-var

One of the earliest risk-parity portfolio formulations is
$$\begin{array}{ll}
\underset{\mathbf{w}}{\textsf{minimize}} & \sum_{i,j=1}^{N}\left(w_{i}\left(\boldsymbol{\Sigma}\mathbf{w}\right)_{i}-w_{j}\left(\boldsymbol{\Sigma}\mathbf{w}\right)_{j}\right)^{2}\\
\textsf{subject to} & \mathbf{1}^T\mathbf{w}=1,\quad\mathbf{w}\in\mathcal{W},
\end{array}$$
which corresponds to $g_{i,j}(\mathbf{w})=\mathbf{w}^T(\mathbf{M}_i-\mathbf{M}_j)\mathbf{w}$ (with $\mathcal{W}$ denoting some other constraints).

Another similar formulation is
$$\begin{array}{ll}
\underset{\mathbf{w},\theta}{\textsf{minimize}} & \sum_{i=1}^{N}\left(w_{i}\left(\boldsymbol{\Sigma}\mathbf{w}\right)_{i} - \theta\right)^{2}\\
\textsf{subject to} & \mathbf{1}^T\mathbf{w}=1,\quad\mathbf{w}\in\mathcal{W}.
\end{array}$$
which corresponds to $g_i(\mathbf{w})=\mathbf{w}^T\mathbf{M}_i\mathbf{w}-\theta$.

In the subsections that follows we explore the computational time required by
`riskParityPortfolioGenSolver` and `riskParityPortfolioSCA` for different formulations.


# Formulation "rc-over-var vs b"
```{r}
set.seed(123)
N <- 100
V <- matrix(rnorm(N ^ 2), nrow = N)
Sigma <- V %*% t(V)

res_slsqp <- riskParityPortfolioGenSolver(Sigma, 
                                          formulation = "rc-over-var vs b",
                                          method = "slsqp")
res_slsqp_nograd <- riskParityPortfolioGenSolver(Sigma,
                                                 formulation = "rc-over-var vs b",
                                                 method = "slsqp",
                                                 use_gradient = FALSE)
res_alabama <- riskParityPortfolioGenSolver(Sigma,
                                            formulation = "rc-over-var vs b",
                                            method = "alabama")
res_alabama_nograd <- riskParityPortfolioGenSolver(Sigma,
                                                   formulation = "rc-over-var vs b",
                                                   method = "alabama",
                                                   use_gradient = FALSE)
res_sca <- riskParityPortfolioSCA(Sigma, formulation = "rc-over-var vs b")

plot(res_slsqp_nograd$elapsed_time, res_slsqp_nograd$obj_fun, type = "b",
     pch=19, cex=.6, col = "blue", xlab = "Elapsed time (seconds)",
     ylab = "Objective function", main = "Convergence trend versus CPU time",
     ylim = c(0, 0.01))
lines(res_alabama$elapsed_time, res_alabama$obj_fun, type = "b", pch=18, cex=.8,
      col = "red")
lines(res_alabama_nograd$elapsed_time, res_alabama_nograd$obj_fun, type = "b", pch=17,
      cex=.8, col = "purple")
lines(res_slsqp$elapsed_time, res_slsqp$obj_fun, type = "b", pch=16, cex=.8,
      col = "green")
lines(res_sca$elapsed_time, res_sca$obj_fun, type = "b", pch=15, cex=.8,
      col = "black")

legend("topright", legend=c("alabama-solver-nograd",
                            "alabama-solver",
                            "slsqp-solver-nograd",
                            "slsqp-solver",
                            "sca"),
       col=c("purple", "red", "blue", "green", "black"), lty=c(1, 1, 1), cex=0.8)
```


# Formulation "rc vs b-times-var"
```{r}
res_slsqp <- riskParityPortfolioGenSolver(Sigma, 
                                          formulation = "rc vs b-times-var",
                                          method = "slsqp")
res_slsqp_nograd <- riskParityPortfolioGenSolver(Sigma,
                                                 formulation = "rc vs b-times-var",
                                                 method = "slsqp",
                                                 use_gradient = FALSE)
res_alabama <- riskParityPortfolioGenSolver(Sigma,
                                            formulation = "rc vs b-times-var",
                                            method = "alabama")
res_alabama_nograd <- riskParityPortfolioGenSolver(Sigma,
                                                   formulation = "rc vs b-times-var",
                                                   method = "alabama",
                                                   use_gradient = FALSE)
res_sca <- riskParityPortfolioSCA(Sigma, formulation = "rc vs b-times-var")

plot(res_slsqp_nograd$elapsed_time, res_slsqp_nograd$obj_fun, type = "b",
     pch=19, cex=.6, col = "blue", xlab = "Elapsed time (seconds)",
     ylab = "Objective function", main = "Convergence trend versus CPU time",
     ylim = c(0, 0.009))
lines(res_alabama$elapsed_time, res_alabama$obj_fun, type = "b", pch=18, cex=.8,
      col = "red")
lines(res_alabama_nograd$elapsed_time, res_alabama_nograd$obj_fun, type = "b", pch=17,
      cex=.8, col = "purple")
lines(res_slsqp$elapsed_time, res_slsqp$obj_fun, type = "b", pch=16, cex=.8,
      col = "green")
lines(res_sca$elapsed_time, res_sca$obj_fun, type = "b", pch=15, cex=.8,
      col = "black")

legend("topright", legend=c("alabama-solver-nograd",
                            "alabama-solver",
                            "slsqp-solver-nograd",
                            "slsqp-solver",
                            "sca"),
       col=c("purple", "red", "blue", "green", "black"), lty=c(1, 1, 1), cex=0.8)
```


# Formulation "rc-over-sd vs b-times-sd"
```{r}
res_slsqp <- riskParityPortfolioGenSolver(Sigma, 
                                          formulation = "rc-over-sd vs b-times-sd",
                                          method = "slsqp")
res_slsqp_nograd <- riskParityPortfolioGenSolver(Sigma,
                                                 formulation = "rc-over-sd vs b-times-sd",
                                                 method = "slsqp",
                                                 use_gradient = FALSE)
res_alabama <- riskParityPortfolioGenSolver(Sigma,
                                            formulation = "rc-over-sd vs b-times-sd",
                                            method = "alabama")
res_alabama_nograd <- riskParityPortfolioGenSolver(Sigma,
                                                   formulation = "rc-over-sd vs b-times-sd",
                                                   method = "alabama",
                                                   use_gradient = FALSE)
res_sca <- riskParityPortfolioSCA(Sigma, formulation = "rc-over-sd vs b-times-sd")

plot(res_slsqp_nograd$elapsed_time, res_slsqp_nograd$obj_fun, type = "b",
     pch=19, cex=.6, col = "blue", xlab = "Elapsed time (seconds)",
     ylab = "Objective function", main = "Convergence trend versus CPU time",
     ylim = c(0, 0.01))
lines(res_alabama$elapsed_time, res_alabama$obj_fun, type = "b", pch=18, cex=.8,
      col = "red")
lines(res_alabama_nograd$elapsed_time, res_alabama_nograd$obj_fun, type = "b", pch=17,
      cex=.8, col = "purple")
lines(res_slsqp$elapsed_time, res_slsqp$obj_fun, type = "b", pch=16, cex=.8,
      col = "green")
lines(res_sca$elapsed_time, res_sca$obj_fun, type = "b", pch=15, cex=.8,
      col = "black")

legend("topright", legend=c("alabama-solver-nograd",
                            "alabama-solver",
                            "slsqp-solver-nograd",
                            "slsqp-solver",
                            "sca"),
       col=c("purple", "red", "blue", "green", "black"), lty=c(1, 1, 1), cex=0.8)
```



## Experiment with real data
```{r}
library(sparseIndexTracking)
library(xts)
data(INDEX_2010)
Sigma <- cov(INDEX_2010$X)

res_slsqp <- riskParityPortfolioGenSolver(Sigma, 
                                          formulation = "rc-over-var vs b",
                                          method = "slsqp")
res_slsqp_nograd <- riskParityPortfolioGenSolver(Sigma,
                                                 formulation = "rc-over-var vs b",
                                                 method = "slsqp",
                                                 use_gradient = FALSE)
res_alabama <- riskParityPortfolioGenSolver(Sigma,
                                            formulation = "rc-over-var vs b",
                                            method = "alabama")
res_alabama_nograd <- riskParityPortfolioGenSolver(Sigma,
                                                   formulation = "rc-over-var vs b",
                                                   method = "alabama",
                                                   use_gradient = FALSE)
res_sca <- riskParityPortfolioSCA(Sigma, formulation = "rc-over-var vs b")

plot(res_alabama_nograd$elapsed_time, res_alabama_nograd$obj_fun, type = "b",
     pch=19, cex=.6, col = "purple", xlab = "Elapsed time (seconds)",
     ylab = "Objective function", main = "Convergence trend versus CPU time")
lines(res_alabama$elapsed_time, res_alabama$obj_fun, type = "b", pch=18, cex=.8,
      col = "red")
lines(res_slsqp_nograd$elapsed_time, res_slsqp_nograd$obj_fun, type = "b", pch=17,
      cex=.8, col = "blue")
lines(res_slsqp$elapsed_time, res_slsqp$obj_fun, type = "b", pch=16, cex=.8,
      col = "green")
lines(res_sca$elapsed_time, res_sca$obj_fun, type = "b", pch=15, cex=.8,
      col = "black")

legend("topright", legend=c("alabama-solver-nograd",
                            "alabama-solver",
                            "slsqp-solver-nograd",
                            "slsqp-solver",
                            "sca"),
       col=c("purple", "red", "blue", "green", "black"), lty=c(1, 1, 1), cex=0.8)
```

## The Role of the Mean Return

Now, let's explore the effects of having the mean return in the optimization problem.
We recall that the optimization problem that include the mean return can be expressed as
$$\begin{array}{ll}
\underset{\mathbf{w},\theta}{\textsf{minimize}} &
R(\mathbf{w}) - \lambda \mathbf{w}^{T}\boldsymbol{\mu}\\
\textsf{subject to} & \mathbf{1}^T\mathbf{w}=1,\quad\mathbf{w}\in\mathcal{W}.
\end{array}$$

```{r}
library(scales)
library(latex2exp)

N <- 100
V <- matrix(rnorm(N ^ 2), nrow = N)
Sigma <- V %*% t(V)
mu <- runif(N)

lambdas <- c(0, 10 ^ (seq(-5, 2, .25)))
mean_return_sca <- c()
risk_parity_sca <- c()
mean_return_gen <- c()
risk_parity_gen <- c()

for (lmd in lambdas) {
  rpp_sca <- riskParityPortfolioSCA(Sigma, mu = mu, lambda = lmd)
  rpp_gen <- riskParityPortfolioGenSolver(Sigma, mu = mu, lambda = lmd)
  mean_return_sca <- c(mean_return_sca, rpp_sca$mean_return)
  risk_parity_sca <- c(risk_parity_sca, rpp_sca$risk)
  mean_return_gen <- c(mean_return_gen, rpp_gen$mean_return)
  risk_parity_gen <- c(risk_parity_gen, rpp_gen$risk)
}

colors <- c(alpha("blue", .5), alpha("red", .5))
plot(risk_parity_sca, mean_return_sca, type = "b", pch=19, cex=.6, col=colors[1],
     xlab = "Risk Parity", ylab = "Mean Return",
     ylim = c(min(mean_return_sca, mean_return_gen), max(mean_return_sca, mean_return_gen)),
     xlim = c(min(risk_parity_sca, risk_parity_gen), max(risk_parity_sca, risk_parity_gen)),
     main = "Mean Return x Risk Parity for SCA and General Solver algorithms")
lines(risk_parity_gen, mean_return_gen, type = "b", pch=19, cex=.6, col=colors[2])
points(risk_parity_sca[1], mean_return_sca[1], pch=24)
points(risk_parity_gen[1], mean_return_gen[1], pch=25)
legend("bottomright", legend=c("SCA", "GenSolver", TeX("SCA w/ $\\lambda = 0$"), TeX("GenSolver w/ $\\lambda = 0$")),
       col=c(colors, "black", "black"), pch = c(19, 19, 24, 25))
```

# References {-}
\setlength{\parindent}{-0.2in}
\setlength{\leftskip}{0.2in}
\setlength{\parskip}{8pt}
\noindent
