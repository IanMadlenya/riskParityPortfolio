---
title: "Design of Risk Parity Portfolios"
author: "Convex Group - HKUST"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    base_format: prettydoc::html_pretty
    theme: tactile
    highlight: vignette
    fig_caption: yes
    number_sections: no
    toc: yes
    toc_depth: 2
  bookdown::pdf_document2:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 2
header-includes:
  \allowdisplaybreaks
indent: yes
csl: ieee.csl
bibliography: refs.bib
vignette: >
  %\VignetteIndexEntry{Design of Risk Parity Portfolios}
  %\VignetteKeyword{portfolio, risk-parity, risk, optimization}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r, echo = FALSE}
library(knitr)
opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center",
  fig.retina = 2,
  out.width = "75%",
  dpi = 96
)
knit_hooks$set(pngquant = hook_pngquant)
#Help on bookdown: https://bookdown.org/yihui/bookdown/
#rmarkdown::render("vignettes/SparseIndexTracking-vignette.Rmd", "all")
#rmarkdown::render("vignettes/SparseIndexTracking-vignette.Rmd", "bookdown::html_document2")
#rmarkdown::render("vignettes/SparseIndexTracking-vignette.Rmd", "bookdown::pdf_document2")
#tools::compactPDF("vignettes/SparseIndexTracking-vignette.pdf", gs_quality = "ebook")
```

-----------
> This vignette illustrates the design of risk-parity portfolios, widely
used by practitioners in the financial industry, with the package
`riskParityPortfolio` (with a comparison with other packages) and gives a
description of the algorithms used.


# Comparison with other packages
Existing packages that I quickly found (a more thorough search is due):

- Package [cccp](https://CRAN.R-project.org/package=cccp) contains function
  `rp` (and the package itself may be useful for solving conic optimization problems)
- Package [FinCovRegularization](https://CRAN.R-project.org/package=FinCovRegularization)
  contains function `RiskParity` (the package may be useful for covariance matrix
  regularization, which is one of my upcoming projects...)


# Usage of the package

```{r}
library(riskParityPortfolio)
library(xts)
library(quantmod)
library(PerformanceAnalytics)

set.seed(123)

N <- 10
stocks_index <- c(1:N)
V <- 2.5 * matrix(rnorm(N ^ 2), nrow = N)
Sigma <- V %*% t(V)

# compute the portfolio weights for the case when Sigma is diagonal
res_diag <- riskParityPortfolioDiagSigma(Sigma)
```

## Formulations
In its simples version, the risk-parity portfolio aims at achieving parity of the risk contributions from the different assets:
$$w_i\left(\boldsymbol{\Sigma}\mathbf{w}\right)_i = w_j\left(\boldsymbol{\Sigma}\mathbf{w}\right)_j \qquad \forall i,j.$$

Assuming that $\boldsymbol{\Sigma}$ is diagonal and with the constraints $\mathbf{1}^T\mathbf{w}=1$ and $\mathbf{w}\ge\mathbf{0}$, the risk budgeting portfolio is
$$w_i = \frac{\sqrt{b_i}/\sqrt{\Sigma_{ii}}}{\sum_{k=1}^N\sqrt{b_k}/\sqrt{\Sigma_{kk}}}, \qquad i=1,\ldots,N.$$
In general, exact parity cannot be achieved and one needs to define a risk term to be minimized: $R(\mathbf{w}) = \sum_{i=1}^{N}\left(g_{i}\left(\mathbf{w}\right)\right)^{2}$. A double-index summation can also be used:
$R(\mathbf{w}) = \sum_{i,j=1}^{N}\left(g_{ij}\left(\mathbf{w}\right)\right)^{2}$.

We condiser the following formulations (equation numbers from the paper):

- (16): rc double-index
- (17): rc vs theta
- (22): rc-over-b vs theta
- (18): norm-rc vs b
- (19): rc-over-b double-index
- (20): rc vs b-times-var
- (21): rc-over-sd vs b-times-sd
- (24): norm-rs
- (26): group-rc-over-sd vs b-times-sd
- (31): factor-rc-over-sd vs b-times-sd
- (32): CVaR-rc-over-sd vs b-times-sd

And here give then one by one...

One of the earliest risk-parity portfolio formulations is
$$\begin{array}{ll}
\underset{\mathbf{w}}{\textsf{minimize}} & \sum_{i,j=1}^{N}\left(w_{i}\left(\boldsymbol{\Sigma}\mathbf{w}\right)_{i}-w_{j}\left(\boldsymbol{\Sigma}\mathbf{w}\right)_{j}\right)^{2}\\
\textsf{subject to} & \mathbf{1}^T\mathbf{w}=1,\quad\mathbf{w}\in\mathcal{W},
\end{array}$$
which corresponds to $g_{i,j}(\mathbf{w})=\mathbf{w}^T(\mathbf{M}_i-\mathbf{M}_j)\mathbf{w}$ (with $\mathcal{W}$ denoting some other constraints).

Another similar formulation is
$$\begin{array}{ll}
\underset{\mathbf{w},\theta}{\textsf{minimize}} & \sum_{i=1}^{N}\left(w_{i}\left(\boldsymbol{\Sigma}\mathbf{w}\right)_{i} - \theta\right)^{2}\\
\textsf{subject to} & \mathbf{1}^T\mathbf{w}=1,\quad\mathbf{w}\in\mathcal{W}.
\end{array}$$
which corresponds to $g_i(\mathbf{w})=\mathbf{w}^T\mathbf{M}_i\mathbf{w}-\theta$.

## Double-index case
```{r, cache = TRUE}
res_gen <- riskParityPortfolioGenSolver(Sigma, formulation = "double-index")
res_qp <- riskParityPortfolioSCA(Sigma, formulation = "double-index")

w_all <- cbind(res_gen$w, res_qp$w, res_diag$w)
colnames(w_all) <- c("risk-parity-gen-solver", "risk-parity-sca", "risk-parity-diag")
rownames(w_all) <- stocks_index
round(w_all, digits = 2)
barplot(t(w_all),
        main = "Portfolio allocation", xlab = "stocks", ylab = "dollars", beside = TRUE,
        legend = colnames(w_all), col = rainbow8equal[1:3])

risk_contrib_all <- cbind(res_gen$r, res_qp$r, res_diag$r)
colnames(risk_contrib_all) <- c("rc-gen-solver", "rc-sca", "rc-diag")
rownames(risk_contrib_all) <- stocks_index
barplot(t(risk_contrib_all),
        main = "Risk contribution", xlab = "stocks", beside = TRUE,
        legend = colnames(w_all), col = rainbow8equal[1:3])
plot(res_gen$elapsed_time, res_gen$obj_fun, type = "b", pch=19, cex=.6,
     col = "red", xlab = "Elapsed time (seconds)",
     ylab = "Objective function", main = "Convergence trend versus CPU time")
lines(res_qp$elapsed_time, res_qp$obj_fun, type = "b", pch=18, cex=.8,
      col = "blue")
legend("topright", legend=c("risk-parity-gen-solver", "risk-parity-sca"),
       col=c("red", "blue"), lty=c(1, 1), cex=0.8)
```


## Experiment with synthetic data: single-index case
```{r, cache = TRUE}
set.seed(123)
N <- 100
V <- 2.5 * matrix(rnorm(N ^ 2), nrow = N)
Sigma <- V %*% t(V)

res_slsqp <- riskParityPortfolioGenSolver(Sigma, formulation = "single-index",
                                        method = "slsqp")
res_slsqp_nograd <- riskParityPortfolioGenSolver(Sigma,
                                                 formulation = "single-index",
                                                 method = "slsqp",
                                                 use_gradient = FALSE)
res_alabama <- riskParityPortfolioGenSolver(Sigma, formulation = "single-index",
                                        method = "alabama")
res_alabama_nograd <- riskParityPortfolioGenSolver(Sigma,
                                                 formulation = "single-index",
                                                 method = "alabama",
                                                 use_gradient = FALSE)
res_qp <- riskParityPortfolioSCA(Sigma, formulation = "single-index")

plot(res_alabama_nograd$elapsed_time, res_alabama_nograd$obj_fun, type = "b", pch=19, cex=.6,
     col = "purple", xlab = "Elapsed time (seconds)",
     ylab = "Objective function", main = "Convergence trend versus CPU time")
lines(res_alabama$elapsed_time, res_alabama$obj_fun, type = "b", pch=18, cex=.8,
      col = "red")
lines(res_slsqp_nograd$elapsed_time, res_slsqp_nograd$obj_fun, type = "b", pch=17, cex=.8,
      col = "blue")
lines(res_slsqp$elapsed_time, res_slsqp$obj_fun, type = "b", pch=16, cex=.8,
      col = "green")
lines(res_qp$elapsed_time, res_qp$obj_fun, type = "b", pch=15, cex=.8,
      col = "black")

legend("topright", legend=c("alabama-solver-nograd",
                            "alabama-solver",
                            "slsqp-solver-nograd",
                            "slsqp-solver",
                            "sca"),
       col=c("purple", "red", "blue", "green", "black"), lty=c(1, 1, 1), cex=0.8)
```

## Experiment with real data: single-index case
```{r, cache = TRUE}
library(sparseIndexTracking)
library(xts)
data(INDEX_2010)

Sigma <- cov(100 * INDEX_2010$X)

res_slsqp <- riskParityPortfolioGenSolver(Sigma, formulation = "single-index",
                                        method = "slsqp")
res_slsqp_nograd <- riskParityPortfolioGenSolver(Sigma,
                                                 formulation = "single-index",
                                                 method = "slsqp",
                                                 use_gradient = FALSE)
res_alabama <- riskParityPortfolioGenSolver(Sigma, formulation = "single-index",
                                        method = "alabama")
res_alabama_nograd <- riskParityPortfolioGenSolver(Sigma,
                                                 formulation = "single-index",
                                                 method = "alabama",
                                                 use_gradient = FALSE)
res_qp <- riskParityPortfolioSCA(Sigma, formulation = "single-index")

plot(res_alabama_nograd$elapsed_time, res_alabama_nograd$obj_fun, type = "b", pch=19, cex=.6,
     col = "purple", xlab = "Elapsed time (seconds)",
     ylab = "Objective function", main = "Convergence trend versus CPU time")
lines(res_alabama$elapsed_time, res_alabama$obj_fun, type = "b", pch=18, cex=.8,
      col = "red")
lines(res_slsqp_nograd$elapsed_time, res_slsqp_nograd$obj_fun, type = "b", pch=17, cex=.8,
      col = "blue")
lines(res_slsqp$elapsed_time, res_slsqp$obj_fun, type = "b", pch=16, cex=.8,
      col = "green")
lines(res_qp$elapsed_time, res_qp$obj_fun, type = "b", pch=15, cex=.8,
      col = "black")

legend("topright", legend=c("alabama-solver-nograd",
                            "alabama-solver",
                            "slsqp-solver-nograd",
                            "slsqp-solver",
                            "sca"),
       col=c("purple", "red", "blue", "green", "black"), lty=c(1, 1, 1), cex=0.8)
```

# Explanation of the algorithms

# References {-}
\setlength{\parindent}{-0.2in}
\setlength{\leftskip}{0.2in}
\setlength{\parskip}{8pt}
\noindent
